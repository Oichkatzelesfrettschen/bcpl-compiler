/**
 * @file oc.h
 * @brief OCODE (Object Code) definitions and enumerations for the BCPL compiler
 * @author Robert Nordier
 * @copyright Copyright (c) 2012 Robert Nordier. All rights reserved.
 *
 * This header file defines the OCODE instruction set used as an intermediate
 * representation in the BCPL compiler. OCODE is generated by the compiler
 * frontend (st.bcpl) and consumed by the various backends (cg.c, llcg.c, etc.).
 *
 * OCODE provides a platform-independent intermediate representation that
 * abstracts the BCPL language constructs into a simpler instruction set
 * suitable for code generation and optimization.
 */

#pragma once

/* Copyright (c) 2012 Robert Nordier. All rights reserved. */

/**
 * @enum ocode_op
 * @brief OCODE operation codes enumeration
 *
 * This enumeration defines all the operation codes used in the OCODE
 * intermediate representation. Each operation represents a specific
 * computation, control flow, or data manipulation instruction.
 *
 * The operations are organized into several categories:
 * - Arithmetic operations (MULT, DIV, PLUS, MINUS, etc.)
 * - Logical operations (LOGAND, LOGOR, NOT, etc.)
 * - Comparison operations (EQ, NE, LS, GR, etc.)
 * - Control flow operations (GOTO, JUMP, JT, JF, etc.)
 * - Memory operations (LG, SG, LP, SP, etc.)
 * - Function operations (FNAP, RETURN, etc.)
 * - Data operations (GETBYTE, PUTBYTE, etc.)
 */
typedef enum ocode_op : int {
  /** @brief Constant true value */
  S_TRUE = 4,
  /** @brief Constant false value */
  S_FALSE = 5,
  /** @brief Right-hand value (load from address) */
  S_RV = 8,
  /** @brief Function application (call function) */
  S_FNAP = 10,
  /** @brief Multiplication operation */
  S_MULT = 11,
  /** @brief Division operation */
  S_DIV = 12,
  /** @brief Remainder (modulo) operation */
  S_REM = 13,
  /** @brief Addition operation */
  S_PLUS = 14,
  /** @brief Subtraction operation */
  S_MINUS = 15,
  /** @brief Query operator (used in conditional expressions) */
  S_QUERY = 16,
  /** @brief Unary negation */
  S_NEG = 17,
  /** @brief Absolute value */
  S_ABS = 19,
  /** @brief Equality comparison */
  S_EQ = 20,
  /** @brief Inequality comparison */
  S_NE = 21,
  /** @brief Less than comparison */
  S_LS = 22,
  /** @brief Greater than comparison */
  S_GR = 23,
  /** @brief Less than or equal comparison */
  S_LE = 24,
  /** @brief Greater than or equal comparison */
  S_GE = 25,
  /** @brief Logical NOT operation */
  S_NOT = 30,
  /** @brief Left bit shift operation */
  S_LSHIFT = 31,
  /** @brief Right bit shift operation */
  S_RSHIFT = 32,
  /** @brief Logical AND operation */
  S_LOGAND = 33,
  /** @brief Logical OR operation */
  S_LOGOR = 34,
  /** @brief Equivalence operation */
  S_EQV = 35,
  /** @brief Non-equivalence operation */
  S_NEQV = 36,
  /** @brief Conditional operation */
  S_COND = 37,
  /** @brief Load parameter (stack-relative addressing) */
  S_LP = 40,
  /** @brief Load global variable */
  S_LG = 41,
  /** @brief Load number (constant) */
  S_LN = 42,
  /** @brief Load string constant */
  S_LSTR = 43,
  /** @brief Load local variable */
  S_LL = 44,
  /** @brief Load parameter pointer */
  S_LLP = 45,
  /** @brief Load global pointer */
  S_LLG = 46,
  /** @brief Load local pointer */
  S_LLL = 47,
  /** @brief Module dependency declaration */
  S_NEEDS = 48,
  /** @brief Module section declaration */
  S_SECTION = 49,
  /** @brief Return from function application */
  S_RTAP = 51,
  /** @brief Unconditional jump (goto) */
  S_GOTO = 52,
  /** @brief Return from function */
  S_RETURN = 67,
  /** @brief Program termination */
  S_FINISH = 68,
  /** @brief Switch statement */
  S_SWITCHON = 70,
  /** @brief Global variable declaration */
  S_GLOBAL = 76,
  /** @brief Store to parameter */
  S_SP = 80,
  /** @brief Store to global variable */
  S_SG = 81,
  /** @brief Store to local variable */
  S_SL = 82,
  /** @brief Store indirect (store through pointer) */
  S_STIND = 83,
  /** @brief Jump instruction */
  S_JUMP = 85,
  /** @brief Jump if true */
  S_JT = 86,
  /** @brief Jump if false */
  S_JF = 87,
  /** @brief End of for loop */
  S_ENDFOR = 88,
  /** @brief Branch label */
  S_BLAB = 89,
  /** @brief Label definition */
  S_LAB = 90,
  /** @brief Stack operation */
  S_STACK = 91,
  /** @brief Store operation */
  S_STORE = 92,
  /** @brief Restore stack */
  S_RSTACK = 93,
  /** @brief Function entry point */
  S_ENTRY = 94,
  /** @brief Save context */
  S_SAVE = 95,
  /** @brief Function return with value */
  S_FNRN = 96,
  /** @brief Return instruction */
  S_RTRN = 97,
  /** @brief Result instruction */
  S_RES = 98,
  /** @brief Result with label */
  S_RESLAB = 99,
  /** @brief Data label */
  S_DATALAB = 100,
  /** @brief Data item (label) */
  S_ITEML = 101,
  /** @brief Data item (number) */
  S_ITEMN = 102,
  /** @brief End of procedure */
  S_ENDPROC = 103,
  /** @brief End marker */
  S_END = 104,
  /** @brief Get byte from string */
  S_GETBYTE = 120,
  /** @brief Put byte into string */
  S_PUTBYTE = 121
} ocode_op;

/** @brief Maximum OCODE operation value */
enum { OPMAX = S_PUTBYTE };

/** @brief Number of attributes per operation in the optab table */
#define OPATTR 4

/**
 * @brief Macro to access the first attribute of an OCODE operation
 * @param x The OCODE operation
 * @return The first attribute value
 */
#define optab1(x) (optab[x][1])

/**
 * @brief Macro to access the second attribute of an OCODE operation
 * @param x The OCODE operation
 * @return The second attribute value
 */
#define optab2(x) (optab[x][2])

/**
 * @brief Macro to access the third attribute of an OCODE operation
 * @param x The OCODE operation
 * @return The third attribute value
 */
#define optab3(x) (optab[x][3])

/**
 * @brief OCODE operation attributes table
 *
 * This table contains attributes for each OCODE operation, including
 * stack effects, operand types, and other code generation hints.
 * The table is indexed by the OCODE operation number and contains
 * OPATTR attributes per operation.
 */
extern const char optab[][OPATTR];
