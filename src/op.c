/**
 * @file op.c
 * @brief Peephole optimizer for x86 assembly code
 * @author Robert Nordier
 * @copyright Copyright (c) 2012 Robert Nordier. All rights reserved.
 *
 * This file implements a peephole optimizer that processes x86 assembly
 * code generated by the BCPL compiler backend (cg.c). The optimizer
 * identifies and eliminates common inefficient instruction sequences,
 * reducing code size and improving performance.
 *
 * ## Design
 * The optimizer is inspired by Christopher W. Fraser's 'copt' tool and
 * uses pattern matching to identify optimization opportunities. It maintains
 * a sliding window of assembly instructions and applies transformation
 * patterns to eliminate redundant operations.
 *
 * ## Optimization Patterns
 * The optimizer recognizes and eliminates patterns such as:
 * - Redundant move operations (mov a,b; mov b,a)
 * - Dead stores and loads
 * - Unnecessary stack operations
 * - Redundant comparisons and jumps
 *
 * ## Implementation
 * The optimizer reads assembly code from stdin, applies optimizations
 * using a pattern matching engine, and outputs optimized code to stdout.
 * Pattern templates are defined in pt.c and linked externally.
 */

/* Copyright (c) 2012 Robert Nordier. All rights reserved. */

/* A peephole optimizer: inspired by copt by Christopher W. Fraser */

#include <ctype.h>
#include <stdbool.h>
#include <stdio.h>

/** @brief Maximum input line size for assembly instructions */
#define SZ 64

/** @brief Number of lines in the optimization buffer */
#define LN 16

/**
 * @brief External pattern table from pt.c
 *
 * This array contains pointers to optimization pattern templates.
 * Each pattern defines a sequence of instructions to match and
 * the corresponding replacement sequence.
 */
extern const char *const *pat[];

/**
 * @brief Register capture buffer for pattern matching
 *
 * During pattern matching, register names and other variable
 * parts of instructions are captured in this buffer for use
 * in generating replacement code.
 */
static char reg[10][SZ];

/**
 * @brief Pattern matching function
 * @param p Pattern string to match against
 * @param s Source string (assembly instruction)
 * @return 0 if match successful, -1 if no match
 *
 * This function implements the core pattern matching algorithm.
 * It supports special syntax for capturing variable parts:
 * - '@' followed by digits captures register names or operands
 * - Captured values are stored in the reg[] array for reuse
 *
 * The matching algorithm handles:
 * - Literal character matching
 * - Variable capture and replay
 * - Flexible whitespace and operand matching
 */
static int match(const char *p, const char *s) {
  char *r;
  int c;

  do {
    c = *p++;
    if (c == '@') {
      while (!isdigit(*p)) {
        if (*s == *p++) {
          return -1;
        }
      }
      r = reg[*p++ - '0'];
      if (*r == 0) {
        while (*s && *s != *p) {
          *r++ = *s++;
        }
        *r = 0;
      } else {
        do {
          if (*r++ != *s++) {
            return -1;
          }
        } while (*r);
      }
    } else if (*s++ != c) {
      return -1;
    }
  } while (c);
  return 0;
}

/* Generate output */
static void gener(const char *p, char *s) {
  const char *r;
  int c;

  do {
    c = *p++;
    if (c == '@' && isdigit(*p)) {
      for (r = reg[*p++ - '0']; *r; r++) {
        *s++ = *r;
      }
    } else {
      *s++ = c;
    }
  } while (c);
}

int main(void) {
  char buf[LN][SZ];
  const char *const **pp, *const *p;
  bool eof;
  int lz, ln, i, j, k;

  for (eof = false, lz = ln = 0;; lz = lz + j & (LN - 1), ln -= j) {
    while (ln < LN && !eof) {
      if (!(eof = fgets(buf[lz + ln & (LN - 1)], SZ, stdin) == NULL))
        ln++;
    }
    if (ln == 0) {
      return 0;
    }
    for (pp = pat; (p = *pp); pp++) {
      for (i = 0; i < 10; i++) {
        *reg[i] = 0;
      }
      for (j = 0, i = lz; p[j]; j++, i++) {
        if (j >= ln || match(p[j], buf[i & (LN - 1)])) {
          break;
        }
      }
      if (p[j]) {
        j = k = 1;
      } else {
        for (p += j + 1, k = 0, i = lz; p[k]; k++, i++) {
          gener(p[k], buf[i & (LN - 1)]);
        }
        break;
      }
    }
    for (i = 0; i < k; i++) {
      fputs(buf[lz + i & (LN - 1)], stdout);
    }
  }
}
