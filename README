BCPLC README

This is an x86 (IA-32) and x86_64 with BIOS and UEFI (x64) port of the "classic" old BCPL compiler
(around 1980) from the Tripos Research Group at Cambridge University. Experimental support exists for retro-modern x86 (IA-16) systems, 
for the compiler written in Chicken Scheme, written in Haskell, Written in Haskell orchestrating C via chicken scheme, and written in Go! 

BCPL was a popular systems programming language during the 1960s
and 1970s, and is of great historical importance: about the time
of the birth of UNIX, BCPL directly inspired the computer language
B and thus had a very big influence on the development of C.

The compiler available here is very close to that featured in the
book, _BCPL: the language and its compiler_ by Martin Richards and
Colin Whitby-Stevens (Cambridge: Cambridge University Press, 1979).

As a real, working computer language implementation, that can be
studied, modified, and played with, the classic BCPL compiler has
a good deal to recommend it. The compiler frontend consists of
only about 2000 lines of BCPL code, and (as supplied here) compiles
to a static (fully-linked) x86 binary that is less than 36000 bytes
in size.

The present distribution supplies a compiler backend (OCODE to x86
code generator), together with peephole optimizer, and reasonably
extensive runtime support. A few revisions have been made to the
compiler frontend -- it looks for header files in a standard location,
for instance -- and  the runtime incorporates support for UNIX
command line arguments and error reporting. Some documentation
that formed part of the original BCPL distribution tape is also
included, as are a few utility programs.

Requirements
============

The compiler relies on a standard set of development tools.  Ensure at
least the following packages are available::

    clang
    make
    cmake
    binutils
    gcc-multilib
    qemu

Running ``./setup.sh`` installs all of the above along with a full
cross‑compilation environment and the IA‑16 toolchain.

Building
========

Before building you may install a comprehensive cross‑compilation
environment by running ``./setup.sh`` as root.  The script configures
package repositories for multiple architectures and installs toolchains
and emulators such as ``qemu`` to enable execution of foreign binaries,
including 16‑bit and 32‑bit x86 programs.  This is optional for a
straightforward native build but recommended when targeting older or
non‑native platforms.

To build the compiler from the top-level directory, run::

    ./scripts/makeall.sh
    ./scripts/makeall.sh install

The build now requires the Clang compiler with C23 support.  The
Makefile selects ``clang`` by default, so no extra arguments are
needed.  Use ``CC=gcc`` or another compiler only if it understands
C23.

Alternatively, you can build directly within ``src/``::

    make -C src
    make -C src install

The Makefiles and CMake build files default to a 64-bit runtime.
Specify ``BITS=32`` (or ``-DBITS=32`` when using CMake) for a 32-bit
runtime or ``BITS=16`` for the experimental IA‑16 build.  Cross builds
may also set ``CROSS_PREFIX`` (for example ``CROSS_PREFIX=i686-linux-gnu-``
or ``CROSS_PREFIX=ia16-elf-``) to select alternate assembler and linker
commands.  The BCPL word size (``WORDSZ``) is selected automatically from
``BITS`` and will be 8 bytes for a 64-bit build, 4 bytes for 32 bit and
2 bytes for 16 bit.

After installation, verify the compiler by running::

    bcplc tools/cmpltest.bcpl

By default the runtime is 64 bit, so running under ``qemu-i386`` is no
longer required.  A 32-bit build remains available for older
environments via ``BITS=32`` or ``-DBITS=32``.

This should print::

    119 TESTS COMPLETED, 0 FAILURE(S)

Martin Richards, the originator of BCPL, has a home page at

    http://www.cl.cam.ac.uk/~mr10/

Richards has continued to develop BCPL, very much as though it were
still a living language, and has a large and complex distribution
of "present day" BCPL available, together with some archive materials.

The web page for this distribution is

    http://www.nordier.com/software/obcpl.html

Build

See INSTALL for detailed build instructions. Build the compiler with

    ./scripts/makeall.sh

and then install it, optionally overriding `PREFIX` to choose an
installation directory:

    ./scripts/makeall.sh install

The project also provides CMake files.  A typical out-of-tree build
looks like::

    cmake -S . -B build -DCMAKE_INSTALL_PREFIX=/usr/local
    cmake --build build
    cmake --install build

The CMake build regenerates ``st.s`` using the freshly built code
generator by default.  Set ``-DBOOTSTRAP=OFF`` to skip this step.  The
``tools`` and ``docs`` targets may be built from the same build
directory.

Ensure the resulting `bcplc` driver is on your `PATH` (or supply a
`BC` variable pointing to it).  If the driver has not yet been
installed, the tests can be run with the freshly built copy in
``src/``.  The driver automatically searches its own directory for the
runtime components, so no installation is required::

    make -C tools BC=../src/bcplc test

After installation the shorter

    make test

will also compile and execute the "cmpltest" suite using the
64-bit runtime system.

Experimental Chicken Scheme Port
-------------------------------
An early experiment using [Chicken Scheme](https://call-cc.org/) lives in
the `ports/chicken/` directory.  It is not built by default and currently
contains only stubs.  Consult `ports/chicken/README.md` for more information.


Robert Nordier
www.nordier.com

Experimental Go Port
====================

The `experiments/bcpl-go` directory contains an in-progress rewrite of
selected components in Go.  The module targets Go 1.24 and currently
implements a basic version of the `bcplc` driver.  Tests can be run with

    go test ./experiments/bcpl-go

The port is incomplete but provides a starting point for further
translation and refactoring in Go.

Experimental LLVM Backend
=========================

An optional tool named ``llcg`` can translate OCODE directly to LLVM IR.
When LLVM is available, build it alongside ``cg`` and ``op`` via::

    make -C src llcg

or with CMake in an out-of-tree build::

    cmake -S . -B build -DLLVM_DIR=/path/to/llvm/cmake
    cmake --build build --target llcg

The generated IR can be compiled to native code using ``clang`` or ``llc``.
For example, to produce an object file directly::

    ./llcg < input.O > prog.ll
    clang -c prog.ll -o prog.o

This bypasses the classic assembler pipeline used by ``cg`` and ``op``.

Development Notes & x86_64 Status (As of Recent Efforts)
=========================================================

Recent efforts have focused on ensuring true native x86_64 compatibility, particularly concerning the system call interface, and beginning code modernization.

**x86_64 Syscall Implementation:**
*   The build system (Makefiles, `bcplc` driver) has been modified to support distinct 64-bit system call object files (`sys64.o`, `su64.o` using `sys$(BITS).o` and `su$(BITS).o` naming).
*   A new assembly file, `src/sys_linux_x86_64.s`, was created to provide syscall wrappers using the native x86_64 Linux ABI (`syscall` instruction, arguments in `rdi, rsi, rdx`, etc.). This replaces the previous approach where 64-bit ELF executables would make 32-bit `int 0x80` syscalls.
*   Error reporting via the BCPL global `RESULT2` (at `G+RESULT2_OFFSET`) has been implemented in these new syscall wrappers.
*   The build system now includes `-g` debug symbols for assembly components.

**Current Status (x86_64) - Persistent Segmentation Fault:**
*   Compiling BCPL programs (e.g., a simple "hello world" or `tools/cmpltest.bcpl`) using the x86_64 build (`BITS=64`) consistently results in a **segmentation fault**.
*   The fault occurs during the execution of `src/st` (the main compiler executable, derived from BCPL code).

**Debugging Efforts & Findings:**
1.  **Initial System Checks:** Verified file integrity, permissions, types (ELF64 for `st`, shell script for `bcplc`), static linking of `st`, and x86_64 host architecture. These were not the cause.
2.  **Address Sanitizer (ASan):**
    *   The C components of the toolchain (`cg`, `op`) were successfully compiled and linked with ASan after installing `libclang-rt-18-dev`.
    *   ASan did *not* report any memory errors within `cg` or `op` during the `bcplc` execution that leads to the segfault. This suggests the memory error originates within `st` or its direct assembly interactions.
3.  **`strace` Analysis:**
    *   This was highly informative: `strace -f src/bcplc ...` showed that `src/st` calls `ioctl(TCGETS)` (likely from an `isatty` call) with a clearly invalid file descriptor (e.g., `86488280`).
    *   The `ioctl` syscall correctly returns `-EBADF` (Bad File Descriptor).
    *   The `SIGSEGV` in `src/st` occurs *after* this failed `ioctl` call.
4.  **Assembly Code Review & Fixes:**
    *   Based on `strace`, the `isatty` wrapper in `src/sys_linux_x86_64.s` was reviewed. It was found to not set `RESULT2` upon `ioctl` failure. This was corrected to ensure `RESULT2` is set with the `errno` (e.g., `EBADF`).
    *   The `sbrk` wrapper was also reviewed for register preservation (`rbx`) and error reporting.
    *   Despite these corrections to the syscall shims, the segmentation fault in `st` persists. This indicates the root cause is likely within `st`'s logic leading to the use of the garbage FD, and its subsequent failure to handle the situation correctly even with improved error reporting from the shims.
5.  **Core Dumps:**
    *   Core dumps are successfully generated (e.g., as `core`) when `st` crashes. This provides an artifact for potential offline `gdb` analysis.
6.  **Debugging Limitations:** The primary impediment to resolving the segfault is the inability to use `gdb` interactively in the current environment to debug `src/st` with the generated core dump.

**Code Modernization Analysis (Phase 1 - Static Analysis):**
*   **`cloc`:** Confirmed that Assembly and C are the main languages for the core compiler/runtime.
*   **`cppcheck` (C files):** Reported no critical errors; only minor style suggestions and informational items.
*   **`lizard` (C files):** Highlighted `gencode()` in `src/cg.c` (Cyclomatic Complexity 114) and `code()` in `src/cg.c` (CCN 23) as major complexity hotspots requiring future refactoring.
*   The BCPL compiler core (`src/st.bcpl`) is substantial (approx. 2000 NLOC).

**Hypothesized Root Cause of Segfault:**
The `st` program (compiled BCPL) appears to be using an uninitialized or corrupted variable as a file descriptor when calling `isatty`. Even with `isatty` now correctly reporting the `EBADF` error via `RESULT2`, the subsequent logic within `st` fails, leading to a memory access violation. The exact nature of this internal error in `st` requires direct debugging of `st`.

**Path Forward:**
1.  **Resolve Segmentation Fault (Highest Priority):**
    *   **Interactive `gdb` debugging of `src/st` using a generated core dump is essential.** This will show the exact instruction and state at the time of the crash.
    *   Focus on the code path in `st` that calls `isatty` and handles its return value and `RESULT2`. Trace how the invalid FD is generated.
2.  **Verify BCPL Runtime & ABI (rt.s, su.s):** Once `st` can be debugged, a thorough review of `rt.s` (runtime) and `su.s` (startup) for 64-bit calling conventions, stack management, and memory layout assumptions is needed to ensure they correctly support the 64-bit compiled BCPL code and interact with the syscall shims.
3.  **Refactor C Code:** After achieving a stable x86_64 runtime, address the complexity in `src/cg.c` (especially `gencode()`).
4.  **Continue Modernization:** Further assess other C components and the BCPL codebase.
